## 背包问题
### 01背包
#### 问题：
有 n 个物品和一个容量为 W 的背包，每个物品有重量 $w_i$ 和 价值 $v_i$ 两种属性，
要求选若干物品放入背包，使得背包中物品的总价值最大而且背包中物品的总重量不超过背包容量。
每个物品只有取与不取两种状态，对应二进制0和1，所以问题也称为「0-1背包问题」

**状态定义**：$f_{i,j}$ 为在只放了前 $i$ 个物品的情况下，容量为 $j$ 的背包所能达到的最大价值。

**状态转移**： 假设当前已经处理好前 $i-1$ 个物品，那么对于第 $i$ 个物品，
  1. 当其不放人背包时，背包的剩余容量不变，背包中物品的总价值也不变，此时最大价值为 $f_{i-1,j}$
  2. 当其放入背包时，背包的剩余容量会减少 $w_i$，背包物品的总价值会增加 $v_i$，此时最大价值为 $f_{i-1,j-w_i} + v_i$
  
**状态转移方程**：(这里假设重量和价值数组都从下标1开始)

$$ f_{i,j} = max(f_{i-1, j}, f_{i-1, j-w_i} + v_i) $$

**优化**：因为对 $f_i$ 有影响的只有 $f_{i-1}$, 所以可以去掉第一维，直接用 $f_i$ 来表示处理当前物品时，背包容量为 $i$ 的最大价值。
得到转移方程为：
$$ f_j = max(f_j, f_{j-w_i} + v_i) $$

**核心代码**：
```
 for(int i = 1; i <= n; i++)
   for(int j = W; j >= w[i]; j--) // 注意：这里必须是反向递推，从W到w[i]，否则一个物品会被多次放入背包。
     f[j] = max(f[j], f[j-w[i]]+v[i])
```

反向递推原因：当前处理物品 $i$ 和 当前状态 $f_{i,j}$，在 $j \ge w_{i}$ 时，$f_{i,j}$ 是会被 $f_{i,j-w_i}$ 所影响的。相当于物品 $i$ 可以被多次放入背包（完全背包问题）。
为了避免这种情况，可以改变枚举顺序，从W枚举到 $w_i$。这样就不会出现这种情况，因为 $f_{i,j}$ 总在 $f_{i, j-w_i}$ 之前被更新。


### 完全背包问题
#### 问题：
完全背包模型与 0-1 背包类似，与 0-1 背包的区别仅在于一个物品可以选取无限次，而非仅能选取一次。

**状态定义**： 设 $f_{i,j}$ 为只能选前 $i$ 个物品时，容量为 $j$ 的背包可以达到的最大价值。  
**转移方程**：朴素的做法是，对于第 $i$ 件物品，枚举其选择次数来转移，复杂度为 $O(n^3)$
$$ f_{i,j} = max_{k=0}^{+\infty} (f_{i-1, j-k\times w_i} + k \times v_i) $$

```
for (int i = 1; i <= n; i++)
  for(int j = W; j >= 1; j--)
    for(int k = 0; k < j / w[i]; k++) 
      dp[j] = max(dp[j], dp[j - k * w[i]] + k * w[i]);
```

**状态转移方程**：

对于 $f_{i, j}$ 只要通过 $f_{i,j-w_i}$ 转移就可以了，因为 $f_{i, j-w_i}$ 已经由 $f_{i, j- 2w_i}$ 更新过，那么 ${f_{i,j-w_i}}$ 就是充分考虑了第 $i$ 件物品所选次数后得到的最优结果。

$$ f_{i,j} = max(f_{i-1,j}, f_{i,j-w[i]}+w[i]) $$
**注意**，这里是 $f_{i, j-w_i}$，而01背包是 $f_{i-1, j-w_i}$，也就是说 $f_{i,j}$ 是通过(dp表中的)上一行和已经本行的前几列推出的，这也是完全背包问题正向递推即可的原因。

**空间优化**：
$$ f_{j} = max(f_{j}, f_{j, j-w_i} + v_i) $$
**可以看到，转移方程和01背包问题相同，只不过01背包是反向递推，而完全背包是正向递推**

**核心代码**：
```
   for (int i = 1; i <= n; i++)
     for (int j = w[i]; j <= W; j++)
       f[j] = max(f[j], f[j-w[i]] + v[i])  // if (f[l - w[i]] + v[i] > f[l]) f[l] = f[l - w[i]] + v[i];
```

### 多重背包
#### 问题
多重背包问题也是 01背包问题的一个变式。与01背包问题的区别是每种物品有 $k_i$ 个，而非一个。与完全背包的不同在于，完全背包每种物品是无限件的，而多重背包中每件物品是有限件的。

朴素的解法是：把「每种物品选$k_i$次」等价转化为 「有$k_i$」个相同的物品，每一物品选一次。这样就转换成了一个01背包问题。套用上面的方法即可。

**状态转移方程**：
$$f_{i,j} = max_{k=0}^{k_i}(f_{i-1, w-k \times w_i} + k \times v_i) $$

复杂度为 $O(W\sum_{i}^{n}k_i)$

**核心代码**
```
for(int i = 1; i <= n; ++i)
  for(int j = W; j>= w[i]; j--)
    for(int k = 0; k <= s[i] && j >= k*w[i]; k++) 
      dp[j] = max(dp[j], dp[j - k * w[i]] + k * v[i]);
```

**二进制优化**

简要原理：32位系统，一个int类型为32位。我们可以用这32个数的不同组合来表示不同的数，也就是在范围内的数都可以变成这个32个数中若干个的累加，即：
$$ x = \sum_{i=0}^{31}a_i \times 2^i $$
我们可以对上面的方程进行扩展，比如对于满足累加性质的函数：$f(a+b) = f(a) + f(b)$，用二进制可以得到：
$$f(x) = \sum_{i=0}^{31}a_i \times f(2^i) $$
同样对于满足：$f(ab) = f(a) \times f(b)$，同样可以进行二进制转化：
$$ f(x) = \prod_{i=0}^{31}g(i) $$
$$ g(i) = \begin{cases} 1 &\text{} a_i == 0 \\ f(2^i) &\text{} a_i == 1 \end{cases} $$
总结起来就是：在某些条件下，$f(x)$ 求解起来非常困难，这时我们可以将其转化为 $f(2^i)$ 的和或者乘积。而求解$f(2^i)$ 是简单的。

**核心代码**
```
int n, m;
cin >> n >> m;
int cnt = 0;
for(int i = 1; i <= n; ++i) {
  int a,b,c; // 体积，价值，数量
  cin >> a >> b >> c;
  int k = 1;
  for(int k = 1; k <=n; k *= 2){
    cnt++;  // 组别
    c -= k; // 物品缩减
    w[cnt] = b * k; // 整体价值
    v[cnt] = a * k; // 整体体积
  }
  if(c > 0) {
    cnt++;
    w[cnt] = b * c;
    v[cnt] = a * c;
  }
}
```

**二维费用背包**

问题：https://www.acwing.com/problem/content/8/

有 $N$ 件物品和一个容量是 $V$ 的背包，背包能承受的最大重量是 $M$。
每件物品只能用一次。体积是 $v_i$，重量是 $m_i$，价值是 $w_i$。
求解将哪些物品装入背包，可使物品总体积不超过背包容量，总重量不超过背包可承受的最大重量，且价值总和最大，输出最大价值。

上述问题很明显是 0-1 背包问题，可是不同的是选一个物品会消耗两种价值（容量、重量），只需在状态中增加一维存放第二种价值即可。

**转移方程**

设$f_{i,j,k}$ 为拿到第 $i$ 个物品，话费为 $j$，开支为 $k$ 的最大价值，则：
$$f_{i,j,k} = max(f_{i-1, j, k}, f_{i-1, j-t_i, k-c_i} + w_i) $$

**压缩数组优化**
$$f_{j,k} = max(f_{j, k}, f_{j-t_i, k-c_i} + w_i) $$
即：
$$f_{i,j} = max(f_{i, j}, f_{i-t_i, j-c_i} + w_i) $$


**核心代码**
```
for(int k = 1; k <= n; k++)
  for(int i = m; i >= v[k]; i--)
    for(int j = t; j >= m[k]; j--)
      dp[i][j] = max(dp[i][j], dp[i-v[k]][j-m[k]] + w[k]);
```

### 数学模型

给定一个$ n $个元素的集合，和一个背包knapsack，其中有：
$$ p_j = profit \; of\; itme\; j $$
$$ w_j = weight\; of\; itme\; j $$
$$ c = capacity\; of\; the\; knapsack\; j $$

选取一个子集使得下面线性规划成立:
$$ maximize \space  z = \sum_{j=1}^{n} p_jx_j $$
$$ s.t. \space \sum_{j=1}^{n}w_jx_j \leq c $$
$$ x_j = 0 \space or \space 1, j \in N = \{1, \dots n\} $$

$$x_j= \left\{
  \begin{matrix} & 1 & if \; item \; i \; is \; selected\\
  & 0 & otherwise
  \end{matrix}\right.
$$

可以规约为一个简单的整数规划问题


### 优化
根据贪心原理，如果费用相同，只需保留价值最高的；当价值相同时，只需要保留费用最低的；当有两件物品 $i$ 和 $j$，并且有： $i$ 的价值大于 $j$ 的价值且 $i$ 的重量小于 $j$，只需要保留 $i$。

### 背包问题变种

1. 求方案数：把求最大值换成求和即可，比如01背包问题，初始状态 $f_0 = 1$，什么也不装也是一种方案。
$$ f_i = \sum\{f_i, f_{i,j-w_i}\}$$