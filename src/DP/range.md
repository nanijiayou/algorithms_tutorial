## 区间DP

### 定义
区间类动态规划是线性动态规划的扩展，它在分阶段的划分问题时，与阶段中元素出现的顺序和由前一阶段的哪些元素合并而来有很大的关系。  
令状态 $f_{i,j}$ 表示将下标位置 $i$ 到 $j$ 的所有元素合并能获得的最大价值，那么：
$$f_{i,j} = max\{f_{i,k}, f_{k+1,j} + cost \}$$
其中，cost 为将这两组元素合并起来的代价。

#### 区间DP特点：
能将问题分解为能两两合并的形式。

#### 求解
对整个问题设最优解，枚举合并点，将问题分解为左右两个部分，然后合并两个部分的最优解得到原问题的最优解。

#### 例子
**石子和并**：

有N堆石子排成一排，每堆石子有一定的数量。现要将N堆石子并成为一堆。
合并的过程只能每次将相邻的两堆石子堆成一堆，每次合并花费的代价为这两堆石子的和，经过N-1次合并后成为一堆。求出总的代价最小值。

**状态定义**：

令 $f_{i,j}$ 表示将区间[i, j]，内所有的石子合并到一起的最小代价。

**转移方程**：
$$f_{i,j} = min(f_{i,k} + f_{k+1, j} + \sum_{t=i}^{j}a_t)$$
令 $sum_i$ 表示数组的前缀和，状态转移方程可以改为：
$$ f_{i,j} = min(f_{i,k} + f_{k+1, j} + sum_j - sum_{i-1}) $$

**如何进行状态转移**

由于计算 $f_{i,j}$ 需要知道所有 $f_{i,k}$ 和 $f_{k+1,j}$ 的值，而这两个中包含的元素的数量都小于 $f_{i,j}$ ，所以我们以 $len = j-i+1$ 作为 DP的阶段。首先从小到大枚举 $len$，然后枚举 $i$ 的值，根据 $len$ 和 $i$ 的公式计算出 $j$ 的值，然后枚举 $k$。时间复杂度为 $O(n^3)$。

**核心代码**
```
  // 枚举区间长度，长度为1的不需要合并，所以不需枚举
  for(len = 1; len <= n; len++)
    // 枚举左端点 
    for(i = 1; i + len - 1 <= n; i++)
      int j = len + i - 1; // 右端点
      for(k = i; k < j; k++)
        f[i][j] = min(f[i][j], f[i][k] + f[k+1][j] + sum[j] - sum[i-1]);
```
